#include "$INSERT_NAME$.h"
#include <math.h>

/**
 * Global variables
 */
$INSERT_VARIABLES$

/**
 * Find maximum between two numbers.
 */
double my_max(double num1, double num2){
    return ( num1 > num2 ) ? num1 : num2;
}

/**
 * Find minimum between two numbers.
 */
double my_min(double num1, double num2){
    return ( num1 > num2 ) ? num2 : num1;
}

/**
 * Absolute value of a number.
 */
double my_absolute(double num){
    return ( num > 0 ) ? num : -num;
}

/**
 * Sparse ADMM solver for the RMPC controller. Uses the projection onto an ellipsoid algorithm.
 * The current system state is given in "pointer_x0".
 * The optimal control action is returned in " u_opt".
 * The number of iterations is returned in "pointer_k".
 * The exit flag is returned in "e_flag".
 *       1: Algorithm converged successfully.
 *      -1: Algorithm did not converge within the maximum number of iterations. Returns current iterate.
 *      -2: Projection algorithm onto ellipsoid did not converge in the current iteration. Algorithm exits.
 * The optimal decision variables are returned in "z_opt" (only if "debug" is #defined).
 */
void RMPC_ADMM(double *pointer_x0, double *u_opt, int *pointer_k, int *e_flag, double *z_opt){

    // Initialize ADMM variables
    int done = 0; // Flag used to determine when the algorithm should exit
    int k = 0; // Number of iterations
    double x0[n];

    // Obtain variables in scaled units
    #if in_engineering == 1
    for(int i = 0; i < nm; i++){
        x0[i] = scaling_x[i]*( pointer_x0[i] - OpPoint_x[i] );
    }
    #endif
    #if in_engineering == 0
    for(int i = 0; i < n; i++){
        x0[i] = pointer_x0[i];
    }
    #endif

    // Update first n elements of beq
    for(int j = 0; j < n; j++){
        b[j] = 0.0;
        for(int i = 0; i < n; i++){
            b[j] = b[j] - AB[j][i]*x0[i];
        }
    }

    // Algorithm
    while(done == 0){

        k += 1; // Increment iteration counter

        // Step 0: Save the value of z into variable z1

        // Compute the first m elements
        for(int j = 0; j < m; j++){
            z1_0[j] = z_0[j];
        }
        // Compute all the other elements except the last n
        for(int l = 0; l < N-1; l++){
            for(int j = 0; j < nm; j++){
                z1[j][l] = z[j][l];
            }
        }
        // Compute the last n elements
        for(int j = 0; j < n; j++){
            z1_N[j] = z_N[j];
        }

        // Step 1: Minimize w.r.t. z_hat

        // Compute vector -Aeq'*H^{-1}*(lambda - rho*z) - beq

        // Compute the firt n elements
        for(int j = 0; j < n; j++){
            mu[j][0] = -Hi[j][0]*( rho[j][0]*z[j][0] - lambda[j][0] ) - b[j];
            for(int i = 0; i < m; i++){
                mu[j][0] = mu[j][0] + AB[j][i + n]*Hi_0[i]*( rho_0[i]*z_0[i] - lambda_0[i] );
            }
        }
        // Compute all the other elements except for the last n
        for(int l = 1; l < N-1; l++){
            for(int j = 0; j < n; j++){
                mu[j][l] = -Hi[j][l]*( rho[j][l]*z[j][l] - lambda[j][l] );
                for(int i = 0; i < nm; i++){
                    mu[j][l] = mu[j][l] + AB[j][i]*Hi[i][l-1]*( rho[i][l-1]*z[i][l-1] - lambda[i][l-1] );
                }
            }
        }
        // Compute the last n elements
        for(int j = 0; j < n; j++){
            aux_N[j] = 0.0;
            for(int i = 0; i < n; i++){
                aux_N[j] = aux_N[j] + P[j][i]*rho_N[i]*z_N[i] - P_half[j][i]*lambda_N[i];
            }
        }
        for(int j = 0; j < n; j++){
            mu[j][N-1] = 0.0;
            for(int i = 0; i < n; i++){
                mu[j][N-1] = mu[j][N-1] - Hi_N[j][i]*aux_N[i];
            }
            for(int i = 0; i < nm; i++){
                mu[j][N-1] = mu[j][N-1] + AB[j][i]*Hi[i][N-2]*( rho[i][N-2]*z[i][N-2] - lambda[i][N-2] );
            }
        }
        
        // Compute mu, the solution of the system of equations W*mu = -Aeq'*H^{-1}*(lambda - rho*z) - beq

        // FORWARD SUBSTITUTION

        // Compute first n elements
        for(int j = 0; j < n; j++){
            for(int i = 0; i <= j-1; i++){
                mu[j][0] = mu[j][0] - Beta[0][i][j]*mu[i][0];
            }
            mu[j][0] = Beta[0][j][j]*mu[j][0];
        }
        // Compute all the other elements except for the last n
        for(int l = 1; l < N-1; l++){
            for(int j = 0; j < n; j++){
                for(int i = 0; i < n; i++){
                    mu[j][l] = mu[j][l] - Alpha[l-1][i][j]*mu[i][l-1];
                }
                for(int i = 0; i <= j-1; i++){
                    mu[j][l] = mu[j][l] - Beta[l][i][j]*mu[i][l];
                }
                mu[j][l] = Beta[l][j][j]*mu[j][l];
            }
        }
        // Compute the last n elements
        for(int j = 0; j < n; j++){
            for(int i = 0; i < n; i++){
                mu[j][N-1] = mu[j][N-1] - Alpha[N-2][i][j]*mu[i][N-2];
            }
            for(int i = 0; i <= j-1; i++){
                mu[j][N-1] = mu[j][N-1] - Beta[N-1][i][j]*mu[i][N-1];
            }
            mu[j][N-1] = Beta[N-1][j][j]*mu[j][N-1];
        }

        // BACKWARD SUBSTITUTION

        // Compute the last n elements
        for(int j = n-1; j >= 0; j--){
            for(int i = n-1; i >= j+1; i--){
                mu[j][N-1] = mu[j][N-1] - Beta[N-1][j][i]*mu[i][N-1];
            }
            mu[j][N-1] = Beta[N-1][j][j]*mu[j][N-1];
        }
        // Compute all the other elements except for the first n
        for(int l = N-2; l >=1; l--){
            for(int j = n-1; j >= 0; j--){
                for(int i = n-1; i >= 0; i--){
                    mu[j][l] = mu[j][l] - Alpha[l][j][i]*mu[i][l+1];
                }
                for(int i = n-1; i >= j+1; i--){
                    mu[j][l] = mu[j][l] - Beta[l][j][i]*mu[i][l];
                }
                mu[j][l] = Beta[l][j][j]*mu[j][l];
            }
        }
        // Compute the first n elements
        for(int j = n-1; j >=0; j--){
            for(int i = n-1; i >=0; i--){
                mu[j][0] = mu[j][0] - Alpha[0][j][i]*mu[i][1];
            }
            for(int i = n-1; i >= j+1; i--){
                mu[j][0] = mu[j][0] - Beta[0][j][i]*mu[i][0];
            }
            mu[j][0] = Beta[0][j][j]*mu[j][0];
        }

        // Compute z_hat

        // Compute the first m elements
        for(int j = 0; j < m; j++){
            z_hat_0[j] = lambda_0[j] - rho_0[j]*z_0[j];
            for(int i = 0; i < n; i++){
                z_hat_0[j] = z_hat_0[j] + AB[i][j+n]*mu[i][0];
            }
            z_hat_0[j] = -Hi_0[j]*z_hat_0[j];
        }
        // Compute all the other elements except for the last n
        for(int l = 0; l < N-1; l++){
            for(int j = 0; j < n; j++){
                z_hat[j][l] = lambda[j][l] - rho[j][l]*z[j][l] - mu[j][l];
            }
            for(int j = n; j < nm; j++){
                z_hat[j][l] = lambda[j][l] - rho[j][l]*z[j][l];
            }
            for(int j = 0; j < nm; j++){
                for(int i = 0; i < n; i++){
                    z_hat[j][l] = z_hat[j][l] + AB[i][j]*mu[i][l+1];
                }
                z_hat[j][l] = -Hi[j][l]*z_hat[j][l];
            }
        }
        // Compute the last n elements
        for(int j = 0; j < n; j++){
            aux_N[j] = lambda_N[j] - rho_N[j]*z_N[j] - mu[j][N-1];
        }
        for(int j = 0; j < n; j++){
            z_hat_N[j] = 0.0;
            for(int i = 0; i < n; i++){
                z_hat_N[j] = z_hat_N[j] - Hi_N[j][i]*aux_N[i];
            }
        }

        // Step 2: Minimize w.r.t. z

        // Compute the first m variables
        for(int j = 0; j < m; j++){
            z_0[j] = my_max(z_hat_0[j] + rho_i_0[j]*lambda_0[j], LBu0[j] );
            z_0[j] = my_min( z_0[j], UBu0[j]);
        }
        // Compute all the other elements except the last n
        for(int l = 0; l < N-1; l++){
            for(int j = 0; j < nm; j++){
                z[j][l] = my_max( z_hat[j][l] + rho_i[j][l]*lambda[j][l], LBz[j][l] );
                z[j][l] = my_min( z[j][l], UBz[j][l]);
            }
        }

        // Compute the last n elements

        // Compute the vector to be projected
        for(int j = 0; j < n; j++){
            project_me[j] = z_hat_N[j];
            for(int i = 0; i < n; i++){
                project_me[j] = project_me[j] + Pinv_half[j][i]*rho_i_N[i]*lambda_N[i];
            }
        }
        // Compute project_me'*P*project_me
        for(int j = 0; j < n; j++){
            aux_N[j] = 0.0;
            for(int i = 0; i < n; i++){
                aux_N[j] = aux_N[j] + P[j][i]*project_me[i];
            }
        }
        vPv = 0.0;
        for(int j = 0; j < n; j++){
            vPv = vPv + project_me[j]*aux_N[j];
        }
        // Project
        if( vPv <= 1){
            for(int j = 0; j < n; j++){
                z_N[j] = project_me[j];
            }
        }
        else{
            vPv = 1/sqrt(vPv);
            for(int j = 0; j < n; j++){
                z_N[j] = vPv*project_me[j];
            }
        }

        // Step 3: Update lambda

        // Compute the first m elements
        for(int j = 0; j < m; j++){
            lambda_0[j] = lambda_0[j] + rho_0[j]*( z_hat_0[j] - z_0[j] );
        }
        // Compute all the other elements except for the last n
        for(int l = 0; l < N-1; l++){
            for(int j = 0; j < nm; j++){
                lambda[j][l] = lambda[j][l] + rho[j][l]*( z_hat[j][l] - z[j][l] );
            }
        }
        // Compute the last n elements
        for(int j = 0; j < n; j++){
            aux_N[j] = rho_N[j]*(z_hat_N[j] - z_N[j]);
        }
        for(int j = 0; j < n; j++){
            for(int i = 0; i < n; i++){
                lambda_N[j] = lambda_N[j] + P_half[j][i]*aux_N[i];
            }
        }
        
        // Step 4: Compute the residual

        // Compute the first m elements
        for(int j = 0; j < m; j++){
            res[j][0] = z1_0[j] - z_0[j];
        }
        // Compute all the other elements except for the last n
        for(int l = 0; l < N-1; l++){
            for(int j = 0; j < nm; j++){
                res[j][l+1] = z1[j][l] - z[j][l];
            }
        }
        // Compute the last n elements
        for(int j = 0; j < n; j++){
            res[j][N] = z1_N[j] - z_N[j];
        }

        // Compute the 1-norm of the residual
        res_1 = 0;
        for(int l = 0; l < N-1; l++){
            for(int j = 0; j < nm; j++){
                res_1 = my_max( res_1, my_absolute(res[j][l]));
            }
        }

        // Step 5: Exit condition

        if(res_1 <= tol){
            done = 1;
            *e_flag = 1;
        }
        else if( k >= k_max ){
            done = 1;
            *e_flag = -1;
        }

    }

    // Control action
    #if in_engineering == 1
    for(int j = 0; j < m; j++){
        u_opt[j] = z_0[j]*scaling_u[j] + OpPoint_u[j];
    }
    #endif
    #if in_engineering == 0
    for(int j = 0; j < m; j++){
        u_opt[j] = z_0[j];
    }
    #endif

    // Resutn solutions
    *pointer_k = k; // Number of iterations

    #ifdef debug
    // Optimal decision variables

    // First m variables
    int count_z = -1;
    for(int j = 0; j < m; j++){
        count_z++;
        z_opt[count_z] = z_0[j];
    }
    // All other elements except the last n
    for(int l = 0; l < N-1; l++){
        for(int j = 0; j < nm; j++){
            count_z++;
            z_opt[count_z] = z[j][l];
        }
    }
    // Last n elements
    for(int j = 0; j < n; j++){
        count_z++;
        z_opt[count_z] = z_N[j];
        
    }
    #endif

}

// This code is generated by the Spcies toolbox: https://github.com/GepocUS/Spcies
// (c) 2020, Pablo Krupa (pkrupa@us.es)

