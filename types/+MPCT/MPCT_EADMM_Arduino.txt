void MPCT_EADMM(float *pointer_u, float *pointer_x0, float *pointer_ref){

    // Obtain variables in scaled units 
    if( in_engineering ){
        for(i = 0; i < nm; i++){
            ref[i] = scaling[i]*(pointer_ref[i] - OpPoint[i]);
        }
        for(i = 0; i < n; i++){
            x0[i] = scaling[i]*(pointer_x0[i] - OpPoint[i]);
        }
    }
    else{
        for(i = 0; i < nm; i++){
            ref[i] = pointer_ref[i];
        }
        for(i = 0; i < n; i++){
            x0[i] = pointer_x0[i];
        }
    }

    // TODO: Warmstart
   
    // Initialize EADMM variables
    done = false;
    k = 0;

    // Algorithm
    while(not done){

        k += 1;
        
        // Problem QP1
        for(i = 0; i < nm; i++) {
            z1[i][0] = max( min( (rho[i][0]*(z3[i][0] + z2[i]) - rho_0[i]*x0[i] + lambda[i][1] - lambda[i][0] )*H1i[i][0], UB0[i]), LB0[i]);
        }
        for(j = 1; j < N; j++) {
            for(i = 0;  i < nm; i++){
                z1[i][j] = max( min( (rho[i][j]*(z2[i] + z3[i][j]) + lambda[i][j+1] )*H1i[i][j], UB[i]), LB[i]);
            }
        }
        for(i = 0; i < nm; i++){
            z1[i][N] = max( min( (rho[i][N]*z3[i][N] (rho[i][N] + rho_s[i])*z2[i] + lambda[i][N+1] + lambda[i][N+2] )*H1i[i][N], UBs[i]), LBs[i]);
        }

        // Problem QP2


        // Compute q2
        for(i = 0; i < nm; i++){
            q2[i] = rho[i][N]*z3[i][N] - (rho[i][N] + rho_s[i])*z1[i][N]) + lambda[i][N+1] + lambda[i][N+2];
        }
        for(i = 0; i < n; i++){
            for(j = 0; j < n; j++){
                q2[i] = q2[i] + T[i][j]*ref[j];
            }
        }
        for(i = n; i < nm; i++){
            for(j = 0; j < m; j++){
                q2[i] = q2[i] + S[i-n][j]*ref[j+n];
            }
        }
        for(j = 0; j < N; j++){
            for(i = 0; i< nm; i++){
                q2[i] = q2[i] + rho[i][j]*(z3[i][j] - z1[i][j]) + lambda[i][j+1];
            }
        }

        // Compute z2
        for(i = 0; i < nm; i++){
            z2[i] = 0;
            for(j = 0; j <  nm; j++){
                z2[i] = z2[i] + W2[i][j]*q2[j];
            }
        }

        // Problem QP3

        // Compute q3
        for(i = 0; i < nm; i++){
            q3[i][0] = rho[i][0]*(z2[i] - z1[i][0]) + lambda[i][1];
        }
        for(j = 1; j< N; j++){
            for(i = 0; i< nm; i++){
                q3[i][j] = rho[i][j]*(z2[i] - z1[i][j]) + lambda[i][j+1];
            }
        }
        for(i = 0; i < nm; i++){
            q3[i][N] = rho[i][N]*(z2[i] - z1[i][N]) + lambda[i][N+1];
        }

        // Compute mu3: Forward substitution


        // Compute first n elements
        for(j = 0; j < n; j++){
            // Compute r.h.s. vector
            mu3[j][0] = H3i[j][1]*q3[j][1];
            for(i = 0; i < nm; i++){
                mu3[j][0] = mu3[j][0] - AB[j][i]*H3i[i][0]*q3[i][0];
            }
            // Forward substitution
            for(i = 0; i <= j-1; i++){
                mu3[j][0] = mu3[j][0] - Beta[0][i][j]*mu3[i][0];
            }
            mu3[j][0] = Beta[0][j][j]*mu3[j][0]; // Divide by the diagonal element
        }
        // Compute all other grout except for the last n elements
        for(l = 1; l < N-1; l++){
            for(j = 0; j < n; j++){
                // Compute r.h.s. vector
                mu3[j][l] = H3i[j][l+1]*q3[j][l+1];
                for(i = 0; i < nm; i++){
                    mu3[j][l] = mu3[j][l] - AB[j][i]*H3i[i][l]*q3[i][l];
                }
                // Forward substitution
                for(i = 0; i < n; i++){
                    mu3[j][l] = mu3[j][l] - Alpha[l-1][i][j]*mu3[i][l-1];
                }
                for(i = 0; i <= j-1; i++){
                    mu3[j][l] = mu3[j][l] - Beta[l][i][j]*mu3[i][l];
                }
                mu3[j][l] = Beta[l][j][j]*mu3[j][l];
            }
        }
        // Compute the last n elements
        for(j = 0; j < n; j++){
            //Compute r.h.h. vector
            mu3[j][N-1] = H3i[j][N]*q3[j][N];
            for(i = 0; i < nm; i++){
                mu3[j][N-1] = mu3[j][N-1] - AB[j][i]*H3i[i][N-1]*q3[i][N-1];
            }
            // Forward substitution
            for(i = 0; i < n; i++){
                mu3[j][N-1] = mu3[j][N-1] - Alpha[N-2][i][j]*mu3[i][N-2];
            }
           for(i = 0; i <= j-1; i++){
                mu3[j][N-1] = mu3[j][N-1] - Beta[N-1][i][j]*mu3[i][N-1];
           }
          mu3[j][N-1] = Beta[N-1][j][j]*mu3[j][N-1];
        }

        // Compute mu3: Backward substitution

        // Compute last n elements
        for(j = n-1; j >= 0; j--){
            for(i = n-1; i >= j+1; i--){
                mu3[j][N-1] = mu3[j][N-1] - Beta[N-1][j][i]*mu3[i][N-1];
            }
            mu3[j][N-1] = Beta[N-1][j][j]*mu3[j][N-1];
        }
        // Compute all other groups except for the first n elements
        for(l = N-2; l >=1; l--){
            for(j = n-1; j >= 0; j--){
                for(i = n-1; i >= 0; i--){
                    mu3[j][l] = mu3[j][l] - Alpha[l][j][i]*mu3[i][l+1];
                }
                for(i = n-1; i >= j+1; i--){
                    mu3[j][l] = mu3[j][l] - Beta[l][j][i]*mu3[i][l];
                }
                mu3[j][l] = Beta[l][j][j]*mu3[j][l];
            }
        }
        // Compute the first n elements
        for(j = n-1; j >=0; j--){
            for(i = n-1; i >=0; i--){
                mu3[j][0] = mu3[j][0] - Alpha[0][j][i]*mu3[i][1];
            }
            for(i = n-1; i >= j+1; i--){
                mu3[j][0] = mu3[j][0] - Beta[0][j][i]*mu3[i][0];
            }
            mu3[j][0] = Beta[0][j][j]*mu3[j][0];
        }
        
        // Compute z3

        // Compute first n+m elements
        for(j = 0; j < nm; j++){
            z3[j][0] = q3[j][0];
            for(i = 0; i < n; i++){
                z3[j][0] = z3[j][0] + AB[i][j]*mu3[i][0];
            }
            z3[j][0] = -H3i[j][0]*z3[j][0];
        }
        // Compute all other groups except for the last n+m
        for(l = 1; l < N; l++){
            for(j = 0; j < n; j++){
                z3[j][l] = q3[j][l] - mu3[j][l-1];
            }
            for(j = n; j < nm; j++){
                z3[j][l] = q3[j][l];
            }
            for(j = 0; j < nm; j++){
                for(i = 0; i < n; i++){
                    z3[j][l] = z3[j][l] + AB[i][j]*mu3[i][l];
                }
                z3[j][l] = -H3i[j][l]*z3[j][l];
            }
        }
        // Compute the last n+m elements
        for(j = 0; j < n; j++){
            z3[j][N] = H3i[j][N]*(mu3[j][N-1] - q3[j][N]);
        }
        for(j = n; j < nm; j++){
            z3[j][N] = -H3i[j][N]*q3[j][N];
        }

        // Compute res
        for(j = 0; j < n; j++){
            res[j][0] = z1[j][0] - x0[j];
        }
        for(l = 0; l < N+1; l++){
            for(j = 0; j < nm; j++){
                res[j][l+1] = z2[j] + z3[j][l] - z1[j][l];
            }
        }
        for(j = 0; j < nm; j++){
            res[j][N+2] = z2[j] - z1[j][N];
        }
        
        // Update lambda
        for(j = 0; j < n; j++){
            lambda[j][0] = lambda[j][0] + rho_0[j]*res[j][0];
        }
        for(l = 1; l < N+2; l++){
            for(j = 0; j < nm; j++){
                lambda[j][l] = lambda[j][l] + rho[j][l-1]*res[j][l];
            }
        }
        for(j = 0; j < nm; j++){
            lambda[j][N+2] = lambda[j][N+2] + rho_s[j]*res[j][N+2];
        }

        // Exit condition
        res_1 = 0;
        for(l = 0; l < N+3; l++){
            for(j = 0; j < nm; j++){
                res_1 = max( res_1, abs(res[j][l]));
            }
        }

        if(res_1 < tol){
            e_flag = true;
            done = true;
        }
        else if(k >= k_max){
            e_flag = false;
            done = true;
        }

        if( done ){
            if( in_engineering ){
                for(j = 0; j < m; j++){
                    pointer_u[j] = z1[n+j][0]*scaling_inv_u[j] + OpPoint[n+j];
                }
            }
            else{
                for(j = 0; j < m; j++){
                    pointer_u[j] = z1[n+j][0];
                }
            }
        }

    }

}

