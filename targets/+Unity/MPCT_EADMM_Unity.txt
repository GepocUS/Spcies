IF Manual THEN (* Manual mode *)

    (* Set control action to manual one *)
    u := u_m;
    (* Set e_flag to 2 *)
    e_flag := 2;
    (* Set k to 0 *)
    k := 0;
    (* Reset booleans *)
    done := false;
        
ELSE (* Automatic mode *)

IF Reset_me THEN 

    (* Reset variables *)
    FOR i := 1 TO nm DO
        z2[i] := 0.0;
    END_FOR;
    FOR j := 1 TO NN+1 DO
        FOR i := 1 TO nm DO
            z3[i, j] := 0.0;
        END_FOR;
    END_FOR;
    FOR j := 1 TO NN+3 DO
        FOR i := 1 TO nm DO
            lambda[i, j] := 0.0;
        END_FOR;
    END_FOR;

    Reset_me := false;

END_IF;

IF NewST THEN (* Do at start of new sample time *)

    (* Reset variables *)
    MPCT_done := false;
    k := 0;
    
    (* Obtain scaled versions of the reference 'ref' and current state 'x0' *)

    IF in_engineering = TRUE THEN
        FOR i := 1 TO nm DO
            ref_inc[i] := scaling[i]*(ref[i] - OpPoint[i]);      
        END_FOR;
	FOR i := 1 TO n DO
	    x0_inc[i] := scaling[i]*(x0[i] - OpPoint[i]);
	END_FOR;
    ELSE
        FOR i := 1 TO nm DO
            ref_inc[i] := ref[i];
        END_FOR;
	FOR i := 1 TO n DO
	    x0_inc[i] := x0[i];
	END_FOR;
    END_IF;
    
END_IF;

(* EADMM algorithm *)
IF NOT MPCT_done THEN

(* Reset variables *)
done := false;
k_inc := 0;

WHILE NOT done DO

    k := k + 1;
    k_inc := k_inc + 1;

    (* Problem 1: Minimize w.r.t. z1 = (xi, ui) *)

    FOR i := 1 TO nm DO
        z1[i, 1] := MAX( MIN( (rho[i, 1]*( x0_inc[i] + z3[i, 1] + z2[i] ) + lambda[i, 2] - lambda[i, 1] )*H1i[i, 1], UB[i]), LB[i]);
    END_FOR;

    FOR j := 2 TO NN DO
        FOR i := 1 TO nm DO
            z1[i, j] := MAX( MIN( (rho[i, j]*( z3[i, j] + z2[i] ) + lambda[i, j+1] )*H1i[i, j], UB[i]), LB[i]);
        END_FOR;
    END_FOR;

    FOR i := 1 TO nm DO
        z1[i, NN+1] := MAX( MIN( (rho[i, NN+1]*( z3[i, NN+1] + 2.0*z2[i] ) + lambda[i, NN+2] + lambda[i, NN+3] )*H1i[i, NN+1], UB[i]), LB[i]);
    END_FOR;

    (* Problem 2: Minimize w.r.t. z2 = (xs, us) *)

    (* Compute q2 *)

    FOR i := 1 TO nm DO
        q2[i] := rho[i, NN+1]*( z3[i, NN+1] - 2.0*z1[i, NN+1] ) + lambda[i, NN+2] + lambda[i, NN+3];
    END_FOR;

    FOR i := 1 TO n DO
        FOR j := 1 TO n DO
            q2[i] := q2[i] + T[i, j]*ref_inc[j];
        END_FOR;
    END_FOR;
    FOR i := n+1 TO nm DO
        FOR j := 1 TO m DO
            q2[i] := q2[i] + S[i-n, j]*ref_inc[j+n];
        END_FOR;
    END_FOR;

    FOR j := 1 TO NN DO
        FOR i := 1 TO nm DO
            q2[i] := q2[i] + rho[i, j]*( z3[i, j] - z1[i, j] )  + lambda[i, j+1];
        END_FOR;
    END_FOR;

    (* Compute z2 *)

    FOR i := 1 TO nm DO
        z2[i] := 0.0;
        FOR j := 1 TO nm DO
            z2[i] := z2[i] + W2[i, j]*q2[j];
        END_FOR;
    END_FOR;
    
    (* Problem  3: Minimize w.r.t. z3 = (hat_xi, hat_ui) *)

    (* Compute q3 *)

    FOR i := 1 TO nm DO
        q3[i, 1] := rho[i, 1]*( z2[i] - z1[i, 1] ) + lambda[i, 2];
    END_FOR;

    FOR j := 2 TO NN DO
        FOR i := 1 TO nm DO
            q3[i, j] := rho[i, j]*( z2[i] - z1[i, j] ) + lambda[i, j+1];
        END_FOR;
    END_FOR;

    FOR i := 1 TO nm DO
        q3[i, NN+1] := rho[i, NN+1]*( z2[i] - z1[i, NN+1] ) + lambda[i, NN+2];
    END_FOR;

    (* Compute mu3 *)

    (* Forward substitution *)

    (* Compute first n *)
    FOR j := 1 TO n DO
        (* Compute c *)
        mu3[j, 1] := H3i[j, 2]*q3[j, 2];
        FOR i := 1 TO nm DO
            mu3[j, 1] := mu3[j, 1] - AB[j, i]*H3i[i, 1]*q3[i, 1];
        END_FOR;
        (* Forward substitution *)
        FOR i := 1 TO j-1 DO
            mu3[j, 1] := mu3[j, 1] - Beta[i, j, 1]*mu3[i, 1];
        END_FOR;
        mu3[j, 1] := Beta[j, j, 1]*mu3[j, 1]; (* Divide by diagonal element *)
    END_FOR;
    (* Compute all other elements except for the last n *)
    FOR l := 2 TO NN-1 DO
        FOR j := 1 TO n DO
            (* Compute c *)
            mu3[j, l] := H3i[j, l+1]*q3[j, l+1];
            FOR i := 1 TO nm DO
                mu3[j, l] := mu3[j, l] - AB[j, i]*H3i[i, l]*q3[i, l];
            END_FOR;
            (* Forward substitution *)
            FOR i := 1 TO n DO
                mu3[j, l] := mu3[j, l] - Alpha[i, j, l-1]*mu3[i, l-1];
            END_FOR;
            FOR i := 1 TO j-1 DO  
                mu3[j, l] := mu3[j, l] - Beta[i, j, l]*mu3[i, l];
            END_FOR;
            mu3[j, l] := Beta[j, j, l]*mu3[j, l];
        END_FOR;
    END_FOR;
    (* Compute the last n elements *)
    FOR j := 1 TO n DO
        (* Compute c *)
        mu3[j, NN] := H3i[j, NN+1]*q3[j, NN+1];
        FOR i := 1 TO nm DO
            mu3[j, NN] := mu3[j, NN] - AB[j, i]*H3i[i, NN]*q3[i, NN];
        END_FOR;
        (* Forward substitution *)
        FOR i := 1 TO n DO
            mu3[j, NN] := mu3[j, NN] - Alpha[i, j, NN-1]*mu3[i, NN-1];
        END_FOR;
        FOR i := 1 TO j-1 DO
            mu3[j, NN] := mu3[j, NN] - Beta[i, j, NN]*mu3[i, NN];
        END_FOR;
        mu3[j, NN] := Beta[j, j, NN]*mu3[j, NN];
    END_FOR;

    (* Backward substitution *)
    
    (* Compute the last n elements *)
    FOR j := n TO  1 BY -1 DO
        FOR i := n TO j+1 BY -1 DO
            mu3[j, NN] := mu3[j, NN] - Beta[j, i, NN]*mu3[i, NN];
        END_FOR;
        mu3[j, NN] := Beta[j, j, NN]*mu3[j, NN];
    END_FOR;
    (* Compute all other elements except for the first n *)
    FOR l := NN-1 TO 2 BY -1 DO
        FOR j := n TO 1 BY -1 DO
            FOR  i := n TO 1 BY -1 DO
                mu3[j, l] := mu3[j, l] - Alpha[j, i, l]*mu3[i, l+1];
            END_FOR;
            FOR i := n TO j+1 BY -1 DO
                mu3[j, l] := mu3[j, l] - Beta[j, i, l]*mu3[i, l];
            END_FOR;
            mu3[j, l] := Beta[j, j, l]*mu3[j, l];
        END_FOR;
    END_FOR;
    (* Compute the first n elements *)
    FOR j := n TO 1 BY -1 DO
        FOR i := n TO 1 BY -1 DO
            mu3[j, 1]  := mu3[j, 1] - Alpha[j, i, 1]*mu3[i, 2];
        END_FOR;
        FOR i := n TO j+1 BY -1 DO
            mu3[j, 1] := mu3[j, 1] - Beta[j, i, 1]*mu3[i, 1];
        END_FOR;
        mu3[j, 1] := Beta[j, j, 1]*mu3[j, 1];
    END_FOR;

    (* Compute z3 *) 

    (* Compute the first n+m elements *)
    FOR j :=  1 TO nm DO
        z3[j, 1] := q3[j, 1];
        FOR i := 1 TO n DO
            z3[j, 1] := z3[j, 1] + AB[i, j]*mu3[i, 1];
        END_FOR;
        z3[j, 1] := -H3i[j, 1]*z3[j, 1];
    END_FOR;
    (* Compute all the other elements except for the last n+m *)
    FOR l := 2 TO NN DO
        FOR j := 1 TO n DO
            z3[j, l] := q3[j, l] - mu3[j, l-1];
        END_FOR;
        FOR j := n+1 TO nm DO
            z3[j, l] := q3[j, l];
        END_FOR;
        FOR j := 1 TO nm DO
            FOR i := 1 TO n DO
                z3[j, l] := z3[j, l] + AB[i, j]*mu3[i, l];
            END_FOR;
            z3[j, l] := -H3i[j, l]*z3[j, l];
        END_FOR;
    END_FOR;
    (* Compute last n+m elements *)
    FOR j := 1 TO n DO
        z3[j, NN+1] := H3i[j, NN+1]*( mu3[j, NN] - q3[j, NN+1] );
    END_FOR;
    FOR j := n+1 TO nm DO
        z3[j, NN+1] := -H3i[j, NN+1]*q3[j, NN+1];
    END_FOR;

    (* Compute res *)

    FOR j := 1 TO n DO
        res[j, 1] := z1[j, 1] - x0_inc[j];
    END_FOR;
    FOR l := 1 TO NN+1 DO
        FOR j := 1 TO nm DO
            res[j, l+1] := z2[j] + z3[j, l] - z1[j, l];
        END_FOR;
    END_FOR;
    FOR j := 1 TO nm DO
        res[j, NN+3] := z2[j] - z1[j, NN+1];
    END_FOR;

    (* Update lambda *)

    FOR j := 1 TO n DO
        lambda[j, 1] := lambda[j, 1] + rho[j, 1]*res[j, 1];
    END_FOR;
    FOR l := 2 TO NN+2 DO
        FOR j:= 1 TO nm DO
            lambda[j, l] := lambda[j, l] + rho[j, l-1]*res[j, l];
        END_FOR;
    END_FOR;
    FOR j := 1 TO nm DO
        lambda[j, NN+3] := lambda[j, NN+3] + rho[j, NN+1]*res[j, NN+3];
    END_FOR;

    (* Exit condition *)

    (* Compute res_1 *)
    res_1 := 0.0;
    FOR l := 1 TO NN+3 DO
        FOR j := 1 TO nm DO
            res_1 := MAX( res_1, ABS(res[j, l]) );
        END_FOR;
    END_FOR;

    IF res_1 &lt;= tol THEN
        done := true;
        e_flag := 1;
        MPCT_done := true;
        Reset_me := true;
    ELSIF k &gt;= k_max THEN
        done := true;
        e_flag := -1;
        MPCT_done := true;
        Reset_me := true;
    ELSIF k_inc &gt;= k_inc_max THEN
        done := true;
        e_flag := 0;
    END_IF;

    IF MPCT_done = true THEN
        IF in_engineering = true THEN
            FOR j := 1 TO m DO
                u[j] := z1[n+j, 1]*scaling_inv_u[j] + OpPoint[n+j];
            END_FOR;
        ELSE
            FOR j := 1 TO m DO
                u[j] := z1[n+j, 1];
            END_FOR;
        END_IF;
    END_IF;
            
END_WHILE;

END_IF;

END_IF;
