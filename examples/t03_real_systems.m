%% Tutorial: working with real systems (operating point and scaling)
% 
% This tutorial covers some of the features that SPCIES includes to help you
% when working with "real" systems.
% In particular, there are two aspects which the toolbox considers:
% 1) When working with a real (non-linear) system, it is often the case that a
%    linear model x(t+1) = A*x(t) + B*u(t) is obtained by some linearization or
%    identification process around a certain "operating point" (x0, u0) of the system.
%    This linear model correctly captures the dynamics of the system when close to the
%    operating point. Therefore, it is often assumed that the system will operate near it.
% 2) The linear model that is obtained from a linearization or identification process is likely
%    to be ill-conditioned, in the sense that some of the states/inputs may be much larger (on
%    average) than the others. For example, when working with a system in which one of the
%    states is a temperature in Kelvin and another state is a pressure in Pascal, you are
%    working with a state that is in the order of 100 with another that is in the order of
%    100.000. This will typically cause numerical conditioning issues in the MPC solver.
%    Therefore, it is recommended to "scale" the system model so that all states and inputs
%    have values that are more or less in the same order of magnitude.
%
% SPCIES offers ways of helping with the above two points in a way which facilitates the
% implementation of the solver generated by the toolbox.
% 
% In particular, let us consider that the "real system" is given by a state X and input U,
% whose elements we say are given in "engineering units" (which we indicate by using a capital
% X and U). That is, its elements describe real, physical aspects of the system in typical
% engineering units [m, atm, K, ms, etc.].
% Let us assume that we obtain a linear model of the real system around the operating
% point (x0, u0), also in "engineering units".
% Finally, the state "x" and input "u" of the linear model are scaled by the diagonal scaling
% matrices "N_x" and "N_u", i.e.,
%   x = N_x * (X - X0)   and   u = N_u * (U - U0),
% obtaining the discrete linear model 
%   u(t+1) = A * x(t) + B * x(t).
% 
% SPCIES helps us when working under this paradigm. In particular, it facilitates how the
% state/input are provided to the generated solver. Let us take a look at how using an example.
clear; clc;

%% STEP 1: Linearization of the "real" system

% Let us consider the Duffing oscillator system described in https://en.wikipedia.org/wiki/Duffing_equation,
% but taking a control action u(t) instead of the cos(w*t) term, with the following parameters and constraints:
param.alpha = 1;
param.beta = 1;
param.delta = 0.9;
param.gamma = 0.02;

% Note that these constraints are expressed in terms of the units of the real system.
% That is, we want the input U applied to the real system to be in the interval [8, 11].
% To accomplish this, the linear prediction model used by the MPC controller will have to consider
% a different pair of constraints for its predicted control inputs.
UBx = [10; 200];
LBx = -UBx;
UBu = 11;
LBu = 8;

% The non-linear ordinary differential equations of the model are provided in sp_utils.Duffing_ode()
% Let us construct a linear state-space model of the system around the operating point:
u0 = 10;
x0 = fsolve(@(xx) sp_utils.Duffing_ode(0, xx, u0, param), zeros(2, 1));

% We can do by using the following function, also provided in the toolbox utility functions:
sysC = sp_utils.Duffing_to_ss(param, x0, u0);

% We then construct a discrete-time model using Matlab's builtin c2d() function:
Ts = 0.2; % Sampling time
sysD = c2d(sysC, Ts);
n = size(sysC.A, 1); % We name the dimensions of the state and control input for convenience
m = size(sysC.B, 2);

%% STEP 2: Controlling the system using LaxMPC the "hard" way

% We put the information of the system into the structure required by Spcies
sys = struct('A', sysD.A, 'B', sysD.B, 'LBx', LBx - x0, 'UBx', UBx - x0, 'LBu', LBu - u0, 'UBu', UBu - u0);
% Note that we need to provide the constraints in terms of the "incremental" units of the linear model sysD,
% since this is the internal prediction model that will be used by the MPC controller. To do so, we need to
% subtract the operating point from the constraints expressed in "engineering" units.

% We then generate the MPC solver (see the basic_tutorial for an in-depth explanation)
Q = diag([0.1, 1000]);
R = 0.1*eye(m);
[~, T] = dlqr(sys.A, sys.B, Q, R);
N = 10;
paramMPC = struct('Q', Q, 'R', R, 'T', T, 'N', N);

options.rho = 1; % Value of the penalty parameter of the ADMM algorithm
options.k_max = 3000; % Maximum number of iterations of the solver
options.tol = 1e-5; % Exit tolerance of the solver

spcies('clear');
spcies('gen', 'sys', sys, 'param', paramMPC,...
       'platform', 'Matlab', 'formulation', 'laxMPC');

% And then control the "real" system using the discrete-time model contained in sys.
num_iter = 50; % Number of simulated sample times
X0 = [0; 0]; % Initial state of the "real" system

% We initialize variables to store the results of the simulation
hX = zeros(n, num_iter+1); % Evolution of the state
hX(:, 1) = X0; % We save the initial state of the simulation
hU = zeros(m, num_iter); % Control actions applied
hK = zeros(1, num_iter); % Number of iterations of the solver
hE = zeros(1, num_iter); % Exit flag of the solver at each iteration

% We set the reference to the linearization point
Ur = u0;
Xr = x0;

X = X0; % Set the state of the "real" system to its initial state
for i = 1:num_iter

    % Call the laxMPC solver.
    % Since our MPC solver considers the linear model sys, we need to subtract the
    % operating point from the current system state and the references.
    % This is because the solver we have generated only "knows" about the linear model
    % sys, whose units are incremental w.r.t. the real system.
    [u, hK(i), hE(i), info] = laxMPC(X - x0, Xr - x0, Ur - u0);
    % Similarly, the generated solver returns the control input in the same "incremental"
    % units, so we need to add the operating point before applying it to the real system.
    U = u + u0;

    % Simulate the "real" system
    [tt, xx] = ode45(@(tt, xx) sp_utils.Duffing_ode(tt, xx, U, param), [0, Ts], X);
    X = xx(end, :)';

    % Save values of X and U
    hU(:, i) = U;
    hX(:, i+1) = X;

end

% We can now plot the results
figure(1); clf(1);
    % States
subplot(2, 2, 1);
plot(0:num_iter, hX(1,:), 'b');
hold on;
plot(0:num_iter, Xr(1)*ones(1, num_iter+1), 'r:'); % Plot the reference
xlabel('Sample time');
ylabel('X(1)');
grid on;
subplot(2, 2, 2);
plot(0:num_iter, hX(2,:), 'b');
hold on;
plot(0:num_iter, Xr(2)*ones(1, num_iter+1), 'r:'); % Plot the reference
xlabel('Sample time');
ylabel('X(2)');
grid on;
    % Input
subplot(2, 2, 3);
input_num = 1; % Determine which input to plot
plot(0:num_iter-1, hU(input_num, :), 'b');
hold on;
plot(0:num_iter-1, Ur(input_num)*ones(1, num_iter), 'r:'); % Plot the reference
xlabel('Sample time');
ylabel('U');
grid on;
    % Number of iterations
subplot(2, 2, 4);
bar(0:num_iter-1, hK);
xlabel('Sample time');
ylabel('Number of iterations');
grid on;

%% STEP 3: Working with normalized models using Spcies (the "easy" way)

% Let us start by pointing out some interesting facts of the previous simulation:
% 1) Note that the inputs and outputs of the generated LaxMPC solver are expressed in
%    incremental units, so we need to manually transform from "engineering" to "incremental"
%    units ourselves (which may me a source of a bug if not done correctly).
% 2) The values of the control input are in the range of 10, whereas the states take smaller values.
%    This discrepancy does is not necessarily a problem, but in many cases it is an indicator of a 
%    likely bad numerical conditioning of the system, which can easily lead to an ill-conditioned
%    MPC solver. The typical way to solve these numerical conditioning issues is to perform some 
%    sort of preconditioning of the solver. Spcies offers a kind of "manual" preconditioning of the
%    system by means of scaling vectors Nx and Nu for the system state and control input, with the
%    objective of allowing the user to scale the system in an attempt to improve the numerical results
%    obtained by the generated solver.
% 3) The control input U reaches its upper bound of 11 during the first sample times. This happens because
%    the internal "incremental" control action of the MPC solver reaches its internal "incremental" upper bound.

% Let us see how we can use Spcies to scale the system using Nx and Nu (to improve the performance of the solver)
% and to tell the toolbox that we want it to generate a solver whose inputs and outputs are given/returned in
% "engineering" units (so that we don't have to worry about making the necessary transformations ourselves).

% We select the scaling "vectors" of the system, which correspond to the diagonal entries of the scaling matrices
% used to obtain the new "normalized" system model whose state and control input (x, u) are given by:
%   x = N_x * (X - X0)   and   u = N_u * (U - U0),
Nx = [1; 1]; % We leave the state as is
Nu = 0.1; % We reduce the input by one order of magnitude

% Spcies includes a useful utility function for obtaining the 'sys' structure required by spcies_gen_controller()
% for the "normalized" system model.
% The function received the "non-normalized" system model, the system constraints (in "engineering" units), the
% operating point (also in "engineering" units) and the scaling vectors Nx and Nu.
% It returns the structure containing the matrices A and B of the new "scaled" model, as well as its constraints
% and a copy of x0, u0, Nx and Nu (also required by spcies_gen_controller()).
sysN = sp_utils.scale_ss(sysD, UBx, LBx, UBu, LBu, x0, u0, Nx, Nu);

% We now adjust the ingredients of the MPC controller to obtain a similar closed-loop behavior of the "real" system.
Q = diag([1, 100]);
R = 1*eye(m);
[~, T] = dlqr(sys.A, sys.B, Q, R);
N = 10;
paramMPC = struct('Q', Q, 'R', R, 'T', T, 'N', N);

% Finally, we regenerate the LaxMPC controller to use the new "scaled" system.
% IMPORTANT: We need to tell Spcies that we want it to generate a solver whose inputs and outputs are
% provided/returned in "engineering" units. To do so, we need to set the "in_engineering" solver options to true.
options.in_engineering = true;
spcies_gen_controller('sys', sysN, 'param', paramMPC, 'options', options,...
                      'platform', 'Matlab', 'formulation', 'laxMPC', 'save_name', 'laxMPC_scaled');

% We can now rerun the closed-loop simulation
hX = zeros(n, num_iter+1); % Evolution of the state
hX(:, 1) = X0;
hU = zeros(m, num_iter); % Control actions applied
hK = zeros(1, num_iter); % Number of iterations of the solver
hE = zeros(1, num_iter); % Exit flag of the solver at each iteration

X = X0; % Set the state of the "real" system to its initial state
for i = 1:num_iter

    % Call the laxMPC solver.
    % Note that, since we set options.in_engineering = true, the solver function
    % receives the system state and reference in "engineering" units and also returns
    % the control input in these units, so we don't need to manually make the transformation.
    [U, hK(i), hE(i), info] = laxMPC_scaled(X, Xr, Ur);
    % Also, note how the scaling we made to the control input (using Nu) has resulted in a 
    % smaller number of iterations of the solver. This will not always be the case for every system,
    % but the scaling matrices Nx and Nu provided by Spcies are another way in which you, the user, can
    % tune the MPC solver to obtain a good performance in practice.

    % Simulate the "real" system
    [tt, xx] = ode45(@(tt, xx) sp_utils.Duffing_ode(tt, xx, U, param), [0, Ts], X);
    X = xx(end, :)';

    % Save values of X and U
    hU(:, i) = U;
    hX(:, i+1) = X;

end

% We can now plot the results
figure(2); clf(2);
    % States
subplot(2, 2, 1);
plot(0:num_iter, hX(1,:), 'b');
hold on;
plot(0:num_iter, Xr(1)*ones(1, num_iter+1), 'r:'); % Plot the reference
xlabel('Sample time');
ylabel('X(1)');
grid on;
subplot(2, 2, 2);
plot(0:num_iter, hX(2,:), 'b');
hold on;
plot(0:num_iter, Xr(2)*ones(1, num_iter+1), 'r:'); % Plot the reference
xlabel('Sample time');
ylabel('X(2)');
grid on;
    % Input
subplot(2, 2, 3);
input_num = 1; % Determine which input to plot
plot(0:num_iter-1, hU(input_num, :), 'b');
hold on;
plot(0:num_iter-1, Ur(input_num)*ones(1, num_iter), 'r:'); % Plot the reference
xlabel('Sample time');
ylabel('U');
grid on;
    % Number of iterations
subplot(2, 2, 4);
bar(0:num_iter-1, hK);
xlabel('Sample time');
ylabel('Number of iterations');
grid on;

