/*
    This file is part of the tutorial "tutorial_C.m".
    It shows you how to implement the plain C solvers generated by Spcies.

    After running the "tutorial_C.m" script, you should see files "myMPCsolver.c"
    and "myMPCsolver.h" in the same directory as this file you are reading.
    If the files are not there please run "tutorial_C.m". If, after doing so, the
    files are still not there, then there is something wrong with your installation
    or setup of the Spcies toolbox (please contact the developers).

    This example performs the same closed-loop simulation of the oscillating masses
    system than the one performed in basic_tutorial.m
    Therefore, the closed-loop results should be exactly the same, since both are using
    the same system, controller and simulation setup.
*/

// We start by including the ".h" file of the generated solver
#include "myMPCsolver.h"
/*
    Before going on to the closed-loop simulation, lets take this opportunity to have a 
    look at what we can find in the generated ".c" and ".h" files.

    -----------------------------------------------------------------------------------
    "myMPCsolver.h"
    -----------------------------------------------------------------------------------
    This header file contains the declaration of the generated MPC solver as well as the
    declaration of the #defines and types required by it.

    Every C solver generated by Spcies starts with a list of #defines required by it. The 
    #defines will vary depending on the chosen MPC formulations, the solver and the options,
    but they usually fall into the following categories:
    - Dimensions of the system and MPC: nn (dimension of system state), mm (dimension of control
     input), nm (nn + mm), NN (prediction horizon), etc.
    - Solver options: k_max (maximum number of iterations), tol (exit tolerance), in_engineering
     (determines if the arguments are given in "engineering" or "incremental" units, as explained
     in tutorial_real_systems.m), rho (ADMM stepsize), rho_i (1/rho), etc.
    - Other defines that depend on the selected options and which control the flow of the solver.
     These are usually in capital letters. For example, the #define SCALAR_RHO in myMPCsolver.h 
     indicates that rho is a scalar, which is used in the solver to simplify some of the operations
     in the ADMM algorithm.

    Next, we always have the declaration of a type called "solution", which is a structure containing
    information about the solution returned by the solver, such as the final primal and dual iterates
    or the computation times (update time, solve_time, polish time and run_time).

    Finally, the file contains the declaration of the function which solves the MPC optimization problem.
    In this example, the name of the function that contains the MPC solver is "laxMPC_ADMM, indicating
    that the MPC formulation is "LaxMPC" and that the optimization method used to solver it is "ADMM".
    The function does not return anything (void) and has the following inputs/outputs (passed by reference):
    INPUTS:
    - double *pointer_x0: A pointer to an array x[nn] which contains the current system state.
    - double *pointer_xr: A pointer to an array xr[nn] which contains the state reference.
    - double *pointer_ur: A pointer to an array ur[mm] which contains the control input reference.
    OUTPUTS:
    - double *u_opt: A pointer to an array u[mm] where the MPC control action will be returned.
    - int *pointer_k: A pointer to an int k where the number of iterations taken by the solver will be returned.
    - int *e_flag: A pointer to an int e_flag where the exit condition of the solver will be returned.
    - solution *sol: A pointer to a solution sol structure where the solver will return its additional information.

    Different MPC formulations and solvers may have slightly different arguments and/or different "solution" types.
    But in general they will resemble the "laxMPC_ADMM" function and "solution" type discussed here.

    -----------------------------------------------------------------------------------
    "myMPCsolver.c"
    -----------------------------------------------------------------------------------
    Nothing particularly interesting to see here. The file contains the source code of the generated solver and some
    basic documentation. Its use requires including the ".h" file, as we have done just before this comment.
*/

#include <stdio.h> // This is not required to run the solver. We only include it to print information to stdout

/*
    The following main() function contains the closed-loop simulation.

    You can compile this file along with "myMPCsolver.c" however you usually compile C.
    For instance, compilation using gcc can be done by running the following command from the terminal:

    Then, execute the generated executable file. You should see the results of the closed-loop simulation
    printed in your terminal.
*/

int main() {

    // We define the arguments (inputs and outputs) required by the laxMPC_ADMM function.
    // We initialize the arrays to the same values used in "basic_tutorial.m".
    double x[nn] = {0.0}; // For storing the system state
    double u[mm] = {0.0}; // For storing the control input
    double xr[nn] = {0.25, 0.25, 0.25, 0.0, 0.0, 0.0}; // State reference
    double ur[mm] = {0.5, 0.5}; // Control input reference
    int k; // For storing the number of iterations of the solver
    int e_flag; // For storing the exit flag of the solver
    solution sol; // For storing the additional information returned by the solver

    // We declare the matrices A and B (AB = [A, B]) of the oscillating systems model so we can simulate it.
    double AB[6][8] = { {0.921583046607005, 0.038422585681011, 0.000522052604120, 0.194730181566844, 0.002603313047213, 0.000021010412519, 0.019735454526605, 0.000000703027327}, {0.076845171362023, 0.845259927849102, 0.076845171362023, 0.005206626094427, 0.189544565884936, 0.005206626094427, 0.000262432356713, 0.000262432356713}, {0.000522052604120, 0.038422585681011, 0.921583046607005, 0.000021010412519, 0.002603313047213, 0.194730181566844, 0.000000703027327, 0.019735454526605}, {-0.768507474078522, 0.368675879581018, 0.010329210538778, 0.921583046607005, 0.038422585681011, 0.000522052604120, 0.194730181566844, 0.000021010412519}, {0.737351759162036, -1.495530022701781, 0.737351759162036, 0.076845171362023, 0.845259927849102, 0.076845171362023, 0.005206626094427, 0.005206626094427}, {0.010329210538778, 0.368675879581018, -0.768507474078522, 0.000522052604120, 0.038422585681011, 0.921583046607005, 0.000021010412519, 0.194730181566844} };

    // Run the closed-loop simulation
    int num_iter = 50;
    for (int t = 1; t <= num_iter; t++) {

        // Call the LaxMPC solver
        laxMPC_ADMM(x, xr, ur, u, &k, &e_flag, &sol);

        // Simulate system
        double x_aux[nn] = {0.0}; // Auxiliary array for computing the successor state
        for (int i = 0; i < nn; i++) {
            for (int j = 0; j < nn; j++) {
                x_aux[i] += AB[i][j] * x[j];
            }
            for (int j = 0; j < mm; j++) {
                x_aux[i] += AB[i][nn+j] * u[j];
            }
        }
        for (int i = 0; i < nn; i++) {
            x[i] = x_aux[i];
        }
        
        // Print information to user
        // The results at each sample time should be the same as the ones obtained in basic_tutorial.m
        printf("----------------------------------------\n");
        printf("Sample time: %d\n", t);
        printf("Control input: u(%d) = [%g, %g]\n", t, u[0], u[1]);
        printf("System state: x(%d) = [%g, %g, %g, %g, %g, %g]\n", t, x[0], x[1], x[2], x[3], x[4], x[5]);
        printf("Solver exit flag: %d\t", e_flag);
        printf("Number of iterations: %d\t", k);
        printf("Computation time: %g\n", sol.run_time);

    }

}

